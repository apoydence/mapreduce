// This file was generated by github.com/nelsam/hel.  Do not
// edit this code by hand unless you *really* know what you're
// doing.  Expect any changes made manually to be overwritten
// the next time hel regenerates this file.

package mapreduce_test

import "github.com/apoydence/mapreduce"

type mockChainLink struct {
	MapCalled chan bool
	MapInput  struct {
		M chan mapreduce.Mapper
	}
	MapOutput struct {
		Ret0 chan mapreduce.ChainLink
	}
	ReduceCalled chan bool
	ReduceInput  struct {
		R chan mapreduce.Reducer
	}
	ReduceOutput struct {
		Ret0 chan mapreduce.ChainLink
	}
	FinalReduceCalled chan bool
	FinalReduceInput  struct {
		R chan mapreduce.FinalReducer
	}
	FinalReduceOutput struct {
		Ret0 chan mapreduce.Functions
	}
}

func newMockChainLink() *mockChainLink {
	m := &mockChainLink{}
	m.MapCalled = make(chan bool, 100)
	m.MapInput.M = make(chan mapreduce.Mapper, 100)
	m.MapOutput.Ret0 = make(chan mapreduce.ChainLink, 100)
	m.ReduceCalled = make(chan bool, 100)
	m.ReduceInput.R = make(chan mapreduce.Reducer, 100)
	m.ReduceOutput.Ret0 = make(chan mapreduce.ChainLink, 100)
	m.FinalReduceCalled = make(chan bool, 100)
	m.FinalReduceInput.R = make(chan mapreduce.FinalReducer, 100)
	m.FinalReduceOutput.Ret0 = make(chan mapreduce.Functions, 100)
	return m
}
func (m *mockChainLink) Map(m_ mapreduce.Mapper) mapreduce.ChainLink {
	m.MapCalled <- true
	m.MapInput.M <- m_
	return <-m.MapOutput.Ret0
}
func (m *mockChainLink) Reduce(r mapreduce.Reducer) mapreduce.ChainLink {
	m.ReduceCalled <- true
	m.ReduceInput.R <- r
	return <-m.ReduceOutput.Ret0
}
func (m *mockChainLink) FinalReduce(r mapreduce.FinalReducer) mapreduce.Functions {
	m.FinalReduceCalled <- true
	m.FinalReduceInput.R <- r
	return <-m.FinalReduceOutput.Ret0
}

type mockFileReader struct {
	ReadCalled chan bool
	ReadOutput struct {
		Ret0 chan []byte
		Ret1 chan error
	}
}

func newMockFileReader() *mockFileReader {
	m := &mockFileReader{}
	m.ReadCalled = make(chan bool, 100)
	m.ReadOutput.Ret0 = make(chan []byte, 100)
	m.ReadOutput.Ret1 = make(chan error, 100)
	return m
}
func (m *mockFileReader) Read() ([]byte, error) {
	m.ReadCalled <- true
	return <-m.ReadOutput.Ret0, <-m.ReadOutput.Ret1
}

type mockFileSystem struct {
	NodesCalled chan bool
	NodesInput  struct {
		Name chan string
	}
	NodesOutput struct {
		IDs chan []string
		Err chan error
	}
	LengthCalled chan bool
	LengthInput  struct {
		Name chan string
	}
	LengthOutput struct {
		Length chan uint64
		Err    chan error
	}
	ReadFileCalled chan bool
	ReadFileInput  struct {
		Name       chan string
		Start, End chan uint64
	}
	ReadFileOutput struct {
		Ret0 chan mapreduce.FileReader
		Ret1 chan error
	}
}

func newMockFileSystem() *mockFileSystem {
	m := &mockFileSystem{}
	m.NodesCalled = make(chan bool, 100)
	m.NodesInput.Name = make(chan string, 100)
	m.NodesOutput.IDs = make(chan []string, 100)
	m.NodesOutput.Err = make(chan error, 100)
	m.LengthCalled = make(chan bool, 100)
	m.LengthInput.Name = make(chan string, 100)
	m.LengthOutput.Length = make(chan uint64, 100)
	m.LengthOutput.Err = make(chan error, 100)
	m.ReadFileCalled = make(chan bool, 100)
	m.ReadFileInput.Name = make(chan string, 100)
	m.ReadFileInput.Start = make(chan uint64, 100)
	m.ReadFileInput.End = make(chan uint64, 100)
	m.ReadFileOutput.Ret0 = make(chan mapreduce.FileReader, 100)
	m.ReadFileOutput.Ret1 = make(chan error, 100)
	return m
}
func (m *mockFileSystem) Nodes(name string) (IDs []string, err error) {
	m.NodesCalled <- true
	m.NodesInput.Name <- name
	return <-m.NodesOutput.IDs, <-m.NodesOutput.Err
}
func (m *mockFileSystem) Length(name string) (length uint64, err error) {
	m.LengthCalled <- true
	m.LengthInput.Name <- name
	return <-m.LengthOutput.Length, <-m.LengthOutput.Err
}
func (m *mockFileSystem) ReadFile(name string, start, end uint64) (mapreduce.FileReader, error) {
	m.ReadFileCalled <- true
	m.ReadFileInput.Name <- name
	m.ReadFileInput.Start <- start
	m.ReadFileInput.End <- end
	return <-m.ReadFileOutput.Ret0, <-m.ReadFileOutput.Ret1
}

type mockNetwork struct {
}

func newMockNetwork() *mockNetwork {
	m := &mockNetwork{}
	return m
}

type mockFunctions struct {
	FunctionsCalled chan bool
	FunctionsOutput struct {
		Ret0 chan []mapreduce.Function
	}
}

func newMockFunctions() *mockFunctions {
	m := &mockFunctions{}
	m.FunctionsCalled = make(chan bool, 100)
	m.FunctionsOutput.Ret0 = make(chan []mapreduce.Function, 100)
	return m
}
func (m *mockFunctions) Functions() []mapreduce.Function {
	m.FunctionsCalled <- true
	return <-m.FunctionsOutput.Ret0
}

type mockMapper struct {
	MapCalled chan bool
	MapInput  struct {
		Value chan []byte
	}
	MapOutput struct {
		Key chan []byte
		Ok  chan bool
	}
}

func newMockMapper() *mockMapper {
	m := &mockMapper{}
	m.MapCalled = make(chan bool, 100)
	m.MapInput.Value = make(chan []byte, 100)
	m.MapOutput.Key = make(chan []byte, 100)
	m.MapOutput.Ok = make(chan bool, 100)
	return m
}
func (m *mockMapper) Map(value []byte) (key []byte, ok bool) {
	m.MapCalled <- true
	m.MapInput.Value <- value
	return <-m.MapOutput.Key, <-m.MapOutput.Ok
}

type mockReducer struct {
	ReduceCalled chan bool
	ReduceInput  struct {
		Value chan [][]byte
	}
	ReduceOutput struct {
		Reduced chan [][]byte
	}
}

func newMockReducer() *mockReducer {
	m := &mockReducer{}
	m.ReduceCalled = make(chan bool, 100)
	m.ReduceInput.Value = make(chan [][]byte, 100)
	m.ReduceOutput.Reduced = make(chan [][]byte, 100)
	return m
}
func (m *mockReducer) Reduce(value [][]byte) (reduced [][]byte) {
	m.ReduceCalled <- true
	m.ReduceInput.Value <- value
	return <-m.ReduceOutput.Reduced
}

type mockFinalReducer struct {
	FinalReduceCalled chan bool
	FinalReduceInput  struct {
		Value chan [][]byte
	}
	FinalReduceOutput struct {
		Reduced chan [][]byte
	}
}

func newMockFinalReducer() *mockFinalReducer {
	m := &mockFinalReducer{}
	m.FinalReduceCalled = make(chan bool, 100)
	m.FinalReduceInput.Value = make(chan [][]byte, 100)
	m.FinalReduceOutput.Reduced = make(chan [][]byte, 100)
	return m
}
func (m *mockFinalReducer) FinalReduce(value [][]byte) (reduced [][]byte) {
	m.FinalReduceCalled <- true
	m.FinalReduceInput.Value <- value
	return <-m.FinalReduceOutput.Reduced
}
